using SharpDebug.Engine;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;

namespace SharpDebug
{
    internal static class ScriptCompiler
    {
        /// <summary>
        /// The automatically generated namespace for the script
        /// </summary>
        internal const string AutoGeneratedNamespace = "AutoGeneratedNamespace";

        /// <summary>
        /// The automatically generated class name for the script
        /// </summary>
        internal const string AutoGeneratedClassName = "AutoGeneratedClassName";

        /// <summary>
        /// The automatically generated script function name
        /// </summary>
        internal const string AutoGeneratedScriptFunctionName = "ScriptFunction";

        /// <summary>
        /// Collection of additional DLLs that should be loaded.
        /// </summary>
        private static readonly string[] AdditionalDlls = new[] { "SharpDebug.CommonUserTypes.dll", "SharpDebug.UI.dll" };

        /// <summary>
        /// Gets the list of search folders.
        /// </summary>
        internal static List<string> SearchFolders { get; private set; } = new List<string>();

        /// <summary>
        /// The default assembly references used by the compiler
        /// </summary>
        internal static readonly string[] DefaultAssemblyReferences = GetDefaultAssemblyReferences();

        /// <summary>
        /// The default list of using commands used by the compiler.
        /// </summary>
        internal static readonly string[] DefaultUsings = new string[] { "System", "System.Linq", "System.Collections.Generic", "SharpDebug", "SharpDebug.Drawing.Interfaces", "SharpDebug.CommonUserTypes" };

        /// <summary>
        /// The default list of using alias commands used by the compiler.
        /// </summary>
        internal static readonly string[] DefaultAliases = new string[] { "std = SharpDebug.CommonUserTypes.NativeTypes.std" };

        /// <summary>
        /// Gets the default assembly references used by the compiler.
        /// </summary>
        private static string[] GetDefaultAssemblyReferences()
        {
            dynamic justInitializationOfDynamics = new List<string>();
            List<string> assemblyReferences = new List<string>();

            assemblyReferences.Add(typeof(System.Object).Assembly.Location);
            assemblyReferences.Add(typeof(System.Linq.Enumerable).Assembly.Location);
            assemblyReferences.Add(typeof(SharpDebug.Drawing.Interfaces.IGraphics).Assembly.Location);
            assemblyReferences.Add(typeof(SharpDebug.Variable).Assembly.Location);
            assemblyReferences.Add(typeof(SharpDebug.InteractiveScriptBase).Assembly.Location);

            // Try to find additional DLLs
            foreach (string dll in AdditionalDlls)
            {
                string defaultPath = typeof(SharpDebug.Variable).Assembly.Location;
                string commonUserTypes = Path.Combine(Path.GetDirectoryName(defaultPath), dll);

                if (File.Exists(commonUserTypes))
                {
                    assemblyReferences.Add(commonUserTypes);
                }
                else
                {
                    foreach (var assembly in AppDomain.CurrentDomain.GetAssemblies())
                        try
                        {
                            if (assembly.Location.EndsWith(dll))
                            {
                                assemblyReferences.Add(assembly.Location);
                                break;
                            }
                        }
                        catch
                        {
                        }
                }
            }

            // Add support for System.Dynamic
            assemblyReferences.Add("Microsoft.CSharp");

            return assemblyReferences.ToArray();
        }

        /// <summary>
        /// Generates the code based on parameters.
        /// </summary>
        /// <param name="usings">The usings.</param>
        /// <param name="importedCode">The imported code.</param>
        /// <param name="scriptCode">The script code.</param>
        /// <param name="scriptBaseClassName">Name of the script base class.</param>
        internal static string GenerateCode(IEnumerable<string> usings, string importedCode, string scriptCode, string scriptBaseClassName = "SharpDebug.ScriptBase")
        {
            StringBuilder codeBuilder = new StringBuilder();

            foreach (var alias in DefaultAliases)
            {
                codeBuilder.Append("using ");
                codeBuilder.Append(alias);
                codeBuilder.AppendLine(";");
            }

            foreach (var u in usings.OrderBy(a => a))
            {
                codeBuilder.Append("using ");
                codeBuilder.Append(u);
                codeBuilder.AppendLine(";");
            }

            codeBuilder.Append("namespace ");
            codeBuilder.AppendLine(AutoGeneratedNamespace);
            codeBuilder.AppendLine("{");
            codeBuilder.Append("public class ");
            codeBuilder.Append(AutoGeneratedClassName);
            codeBuilder.Append(" : ");
            codeBuilder.AppendLine(scriptBaseClassName);
            codeBuilder.AppendLine("{");
            codeBuilder.AppendLine(importedCode);
            codeBuilder.Append("public void ");
            codeBuilder.Append(AutoGeneratedScriptFunctionName);
            codeBuilder.AppendLine("()");
            codeBuilder.AppendLine("{");
            codeBuilder.AppendLine(scriptCode);
            codeBuilder.AppendLine("}");
            codeBuilder.AppendLine("}");
            codeBuilder.AppendLine("}");
            return codeBuilder.ToString();
        }

        /// <summary>
        /// Extracts the metadata from user assemblies.
        /// </summary>
        /// <param name="assemblies">The assemblies.</param>
        internal static UserTypeMetadata[] ExtractMetadata(IEnumerable<Assembly> assemblies)
        {
            List<UserTypeMetadata> metadata = new List<UserTypeMetadata>();

            foreach (var assembly in assemblies)
                metadata.AddRange(ExtractMetadata(assembly));
            return metadata.ToArray();
        }

        /// <summary>
        /// Extracts the metadata from user assembly.
        /// </summary>
        /// <param name="assembly">The assembly containing user types.</param>
        internal static IEnumerable<UserTypeMetadata> ExtractMetadata(Assembly assembly)
        {
            List<Type> nextTypes = assembly.ExportedTypes.ToList();

            while (nextTypes.Count > 0)
            {
                List<Type> types = nextTypes;

                nextTypes = new List<Type>();
                foreach (var type in types)
                {
                    foreach (UserTypeMetadata metadata in UserTypeMetadata.ReadFromType(type))
                        yield return metadata;
                    nextTypes.AddRange(type.GetNestedTypes(BindingFlags.NonPublic));
                }
            }
        }
    }
}
