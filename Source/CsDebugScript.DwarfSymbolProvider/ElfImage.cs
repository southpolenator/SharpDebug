using ELFSharp.ELF;
using ELFSharp.ELF.Sections;
using System.Linq;
using System.Collections.Generic;
using CsDebugScript.Engine.Utility;
using System;

namespace CsDebugScript.DwarfSymbolProvider
{
    /// <summary>
    /// Simple ELF image reader.
    /// </summary>
    /// <seealso cref="CsDebugScript.DwarfSymbolProvider.IDwarfImage" />
    internal class ElfImage : IDwarfImage
    {
        /// <summary>
        /// The ELF interface
        /// </summary>
        private ELF<ulong> elf;

        /// <summary>
        /// Cache of ordered sections.
        /// </summary>
        private SimpleCache<Section<ulong>[]> sectionRegions;

        /// <summary>
        /// Cache of sections finder.
        /// </summary>
        private SimpleCache<MemoryRegionFinder> sectionRegionFinder;

        /// <summary>
        /// Initializes a new instance of the <see cref="ElfImage"/> class.
        /// </summary>
        /// <param name="path">The image path.</param>
        /// <param name="loadOffset">Offset from where image was loaded.</param>
        public ElfImage(string path, ulong loadOffset = 0)
        {
            elf = ELFReader.Load<ulong>(path);
            LoadOffset = loadOffset;
            foreach (var segment in elf.Segments)
            {
                if (segment.Type == ELFSharp.ELF.Segments.SegmentType.ProgramHeader)
                {
                    CodeSegmentOffset = segment.Address - (ulong)segment.Offset;
                    break;
                }
            }

            List<PublicSymbol> publicSymbols = new List<PublicSymbol>();
            SymbolTable<ulong> symbols = elf.Sections.FirstOrDefault(s => s.Type == SectionType.SymbolTable) as SymbolTable<ulong>;

            if (symbols == null || !symbols.Entries.Any())
            {
                symbols = elf.Sections.FirstOrDefault(s => s.Type == SectionType.DynamicSymbolTable) as SymbolTable<ulong>;
            }

            if (symbols != null)
            {
                foreach (SymbolEntry<ulong> symbol in symbols.Entries)
                {
                    publicSymbols.Add(new PublicSymbol(symbol.Name, symbol.Value - CodeSegmentOffset));
                }
            }
            PublicSymbols = publicSymbols;
            sectionRegions = SimpleCache.Create(() => elf.Sections.Where(s => s.LoadAddress > 0).OrderBy(s => s.LoadAddress).ToArray());
            sectionRegionFinder = SimpleCache.Create(() => new MemoryRegionFinder(sectionRegions.Value.Select(s => new MemoryRegion { BaseAddress = s.LoadAddress, RegionSize = s.Size }).ToArray()));
        }

        /// <summary>
        /// Gets the public symbols.
        /// </summary>
        public IReadOnlyList<PublicSymbol> PublicSymbols { get; private set; }

        /// <summary>
        /// Gets the code segment offset.
        /// </summary>
        public ulong CodeSegmentOffset { get; private set; }

        /// <summary>
        /// Gets the image load offset.
        /// </summary>
        public ulong LoadOffset { get; private set; }

        /// <summary>
        /// Gets the debug data.
        /// </summary>
        public byte[] DebugData
        {
            get
            {
                return LoadSection(".debug_info");
            }
        }

        /// <summary>
        /// Gets the debug data description.
        /// </summary>
        public byte[] DebugDataDescription
        {
            get
            {
                return LoadSection(".debug_abbrev");
            }
        }

        /// <summary>
        /// Gets the debug data strings.
        /// </summary>
        public byte[] DebugDataStrings
        {
            get
            {
                return LoadSection(".debug_str");
            }
        }

        /// <summary>
        /// Gets the debug frame.
        /// </summary>
        public byte[] DebugFrame
        {
            get
            {
                return LoadSection(".debug_frame");
            }
        }

        /// <summary>
        /// Gets the exception handling frames used for unwinding (generated by usually GCC compiler).
        /// </summary>
        public byte[] EhFrame
        {
            get
            {
                return LoadSection(".eh_frame");
            }
        }

        /// <summary>
        /// Gets the debug line.
        /// </summary>
        public byte[] DebugLine
        {
            get
            {
                return LoadSection(".debug_line");
            }
        }

        /// <summary>
        /// Gets the address of exception handling frames stream after loading into memory.
        /// </summary>
        public ulong EhFrameAddress
        {
            get
            {
                return GetSectionAddress(".eh_frame");
            }
        }

        /// <summary>
        /// Gets the address of text section after loading into memory.
        /// </summary>
        public ulong TextSectionAddress
        {
            get
            {
                return GetSectionAddress(".text");
            }
        }

        /// <summary>
        /// Gets the address of data section after loading into memory.
        /// </summary>
        public ulong DataSectionAddress
        {
            get
            {
                return GetSectionAddress(".data");
            }
        }

        /// <summary>
        /// Gets a value indicating whether this <see cref="IDwarfImage" /> is 64 bit image.
        /// </summary>
        /// <value>
        ///   <c>true</c> if is 64 bit image; otherwise, <c>false</c>.
        /// </value>
        public bool Is64bit
        {
            get
            {
                return elf.Class == Class.Bit64;
            }
        }

        /// <summary>
        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
        /// </summary>
        public void Dispose()
        {
            elf.Dispose();
        }

        /// <summary>
        /// Gets address offset within module when it is loaded.
        /// </summary>
        /// <param name="address">Virtual address that points where something should be loaded.</param>
        public ulong NormalizeAddress(ulong address)
        {
            Section<ulong> section;

            if (address < sectionRegions.Value[0].LoadAddress)
                section = elf.Sections.FirstOrDefault(s => s.LoadAddress <= address && s.LoadAddress + s.Size > address);
            else
            {
                int sectionIndex = sectionRegionFinder.Value.Find(address);
                section = sectionIndex >= 0 ? sectionRegions.Value[sectionIndex] : null;
            }

            if (section != null && section.Flags.HasFlag(SectionFlags.Allocatable))
                return address - CodeSegmentOffset + LoadOffset;
            return address - CodeSegmentOffset;
        }

        /// <summary>
        /// Loads the section bytes specified by the name.
        /// </summary>
        /// <param name="sectionName">Name of the section.</param>
        /// <returns>Section bytes.</returns>
        private byte[] LoadSection(string sectionName)
        {
            foreach (ISection section in elf.Sections)
            {
                if (section.Name == sectionName)
                {
                    return section.GetContents();
                }
            }

            return new byte[0];
        }

        /// <summary>
        /// Gets the section address after loading into memory.
        /// </summary>
        /// <param name="sectionName">Name of the section.</param>
        /// <returns>Address of section after loading into memory.</returns>
        private ulong GetSectionAddress(string sectionName)
        {
            foreach (Section<ulong> section in elf.Sections)
            {
                if (section.Name == sectionName)
                {
                    ulong loadOffset = section.Flags.HasFlag(SectionFlags.Allocatable) ? LoadOffset : 0;

                    return section.Offset + CodeSegmentOffset + loadOffset;
                }
            }

            return ulong.MaxValue;
        }
    }
}
